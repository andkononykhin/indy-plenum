#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import argparse
import os

import json
import pprint

from collections import OrderedDict

import asyncio
import concurrent.futures

from stp_core.common.log import getlogger
from plenum.common.config_util import getConfig

from stp_core.common.log import Logger


logger = getlogger()
config = getConfig()

clients = {}  # task -> (reader, writer)


async def handle_client(client_reader, client_writer):
    # give client a chance to respond, timeout after 10 seconds
    while True:
        try:
            data = await client_reader.readline()
        except concurrent.futures.CancelledError:
            logger.warning("task has been cancelled")
            return
        except Exception as e:
            logger.exception("failed to readline")
            return
        else:
            if data is None:
                logger.warning("Expected data, received None")
                return
            elif not data:
                logger.warning("EOF received, closing connection")
                return
            else:
                #print(jsonpickle.decode(data.decode()))
                logger.debug("Received data: {}".format(data))
                stats = json.loads(data.decode(), object_pairs_hook=OrderedDict)
                print(json.dumps(stats, indent=2))


def accept_client(client_reader, client_writer):
    logger.info("New Connection")
    task = asyncio.Task(handle_client(client_reader, client_writer))

    clients[task] = (client_reader, client_writer)

    def client_done(task):
        del clients[task]
        client_writer.close()
        logger.info("End Connection")

    task.add_done_callback(client_done)


def main():

    def check_unsigned(s):
        res = None
        try:
            res = int(s)
        except ValueError:
            pass
        if res is None or res <= 0:
            raise argparse.ArgumentTypeError(("{!r} is incorrect, "
                                              "should be int > 0").format(s,))
        else:
            return res

    parser = argparse.ArgumentParser(
        description=(
            "Tool to explore and gather statistics about running validator"
        ),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Verbose mode (command line)")
    parser.add_argument("--json", action="store_true",
                        help="Format output as JSON (ignores -v")

    statfile_group = parser.add_argument_group(
        "statfile", "settings for exploring validator stats from stat file"
    )

    statfile_group.add_argument("--statfile", metavar="PATH",
                        default=os.path.join(config.baseDir, "stats.json"),
                        help=("Path to stats file"))
    statfile_group.add_argument("--watch", action="store_true",
                        help="Watch for stats file updates")

    socket_group = parser.add_argument_group(
        "socket", "settings for exploring validator stats from socket"
    )

    socket_group.add_argument("--listen", action="store_true",
                        help="Listen socket for stats (ignores --statfile)")

    socket_group.add_argument(
        "-i", "--ip", metavar="IP", default=config.STATS_SERVER_IP,
        help="Server IP"
    )
    socket_group.add_argument(
        "-p", "--port", metavar="PORT", default=config.STATS_SERVER_PORT,
        type=check_unsigned, help="Server port"
    )

    other_group = parser.add_argument_group(
        "other", "other settings"
    )

    other_group.add_argument("--stdlog", action="store_true",
                        help="Enable logging to stdout")


    args = parser.parse_args()

    config.enableStdOutLogging = args.stdlog
    logFileName = os.path.join(config.baseDir, os.path.basename(sys.argv[0] + ".log"))
    Logger().enableFileLogging(logFileName)

    logger.debug("Cmd line arguments: {}".format(args))

    if args.listen:
        logger.info("Starting server on {}:{} ...".format(args.ip, args.port))
        print("Starting server on {}:{} ...".format(args.ip, args.port))

        loop = asyncio.get_event_loop()
        coro = asyncio.start_server(accept_client, args.ip, args.port, loop=loop)
        server = loop.run_until_complete(coro)

        logger.info("Serving on {}:{} ...".format(args.ip, args.port))
        print('Serving on {} ...'.format(server.sockets[0].getsockname()))

        # Serve requests until Ctrl+C is pressed
        try:
            loop.run_forever()
        except KeyboardInterrupt:
            pass

        logger.info("Stopping server ...")
        print("Stopping server ...")

        # Close the server
        server.close()
        for task in clients.keys():
            task.cancel()
        loop.run_until_complete(server.wait_closed())
        loop.close()
    else:
        logger.info("Reading file {} ...".format(args.statfile))
        with open(args.statfile) as f:
            stats = json.loads(f.read(), object_pairs_hook=OrderedDict)
        logger.debug("Data {}".format(stats))
        print(json.dumps(stats, indent=2))

    logger.info("Done")


if __name__ == "__main__":
    sys.exit(main())
