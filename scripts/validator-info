#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import argparse
import os
import datetime

import json
import pprint

from collections import OrderedDict

import asyncio
import concurrent.futures

from stp_core.common.log import getlogger
from plenum.common.config_util import getConfig

from stp_core.common.log import Logger


config = getConfig()

logger = None # to make flake8 happy
clients = {}  # task -> (reader, writer)


async def handle_client(client_reader, client_writer):
    # give client a chance to respond, timeout after 10 seconds
    while True:
        try:
            data = await client_reader.readline()
        except concurrent.futures.CancelledError:
            logger.warning("task has been cancelled")
            return
        except Exception as e:
            logger.exception("failed to readline")
            return
        else:
            if data is None:
                logger.warning("Expected data, received None")
                return
            elif not data:
                logger.warning("EOF received, closing connection")
                return
            else:
                logger.debug("Received data: {}".format(data))
                stats = json.loads(data.decode(),
                                   object_pairs_hook=OrderedDict)
                print(json.dumps(stats, indent=2))


def accept_client(client_reader, client_writer):
    logger.info("New Connection")
    task = asyncio.Task(handle_client(client_reader, client_writer))

    clients[task] = (client_reader, client_writer)

    def client_done(task):
        del clients[task]
        client_writer.close()
        logger.info("End Connection")

    task.add_done_callback(client_done)


def output_json(stats):
    print(json.dumps(stats, indent=2))


def output_plain(stats, verbose=False):

    def format_state(state):
        return "is {} {}".format(
            "currently" if state == "running" else "", state
        )

    def format_port(port, protocol, ip):
        return "{}{}".format(
            port,
            "/{} on {}".format(protocol, ip) if verbose else ""
        )

    def format_uptime(secs):
        days, remainder = divmod(secs, 86400)
        hours, remainder = divmod(remainder, 3600)
        minutes, seconds = divmod(remainder, 60)
        parts = []

        for s, v in zip(['day', 'hour', 'minute', 'second'],
                        [days, hours, minutes, seconds]):
            if v or len(parts):
                parts.append("{} {}{}".format(v, s, '' if v == 1 else 's'))

        return ", ".join(parts) if parts else '0 seconds'

    lines = [
        "Validator {} {}".format(stats['alias'], format_state(stats['state'])),
        "#Current time:     {}".format(
            datetime.datetime.fromtimestamp(
                stats['timestamp']).strftime(
                    "%A, %B %{0}d, %Y %{0}I:%M:%S %p".format(
                        '#' if os.name == 'nt' else '-'))
        ),
        "Validator DID:    {}".format(stats['did']),
        "Verification Key: {}".format(stats['verkey']),
        "Node Port:        {}".format(
            format_port(
                stats['bindings']['node']['port'],
                stats['bindings']['node']['protocol'],
                stats['bindings']['node']['ip'])
        ),
        "Client Port:      {}".format(
            format_port(
                stats['bindings']['client']['port'],
                stats['bindings']['client']['protocol'],
                stats['bindings']['client']['ip'])
        ),
        "Metrics:",
        "  Uptime: {}".format(format_uptime(stats['metrics']['uptime'])),
        "#  Total Config Transactions:  {}".format(
            stats['metrics']['transaction-count']['config']),
        "  Total Ledger Transactions:  {}".format(
            stats['metrics']['transaction-count']['ledger']),
        "  Total Pool Transactions:    {}".format(
            stats['metrics']['transaction-count']['pool']),
        "  Read Transactions/Seconds:  {}".format(
            stats['metrics']['average-per-second']['read-transactions']),
        "  Write Transactions/Seconds: {}".format(
            stats['metrics']['average-per-second']['write-transactions']),
        "Reachable Hosts:   {}/{}".format(
            stats['pool']['reachable']['count'], stats['pool']['total-count'])
    ]

    lines += [
        "#  {}".format(alias) for alias in stats['pool']['reachable']['list']
    ]

    lines += [
        "Unreachable Hosts: 1/6".format(
            stats['pool']['unreachable']['count'],
            stats['pool']['total-count']
        )
    ]

    lines += [
        "#  {}".format(alias) for alias in stats['pool']['unreachable']['list']
    ]

    lines += [
        "#Software Versions:",
        "#  indy-node: 1.0.28".format(stats['software']['indy-node']),
        "#  sovrin:    1.0.3".format(stats['software']['sovrin'])
    ]

    # skip lines with started with '#' if not verbose
    # or remove '#' otherwise
    print("\n".join(
        [l[(1 if l[0] == '#' else 0):]
            for l in lines if verbose or l[0] != '#'])
    )


def main():

    def check_unsigned(s):
        res = None
        try:
            res = int(s)
        except ValueError:
            pass
        if res is None or res <= 0:
            raise argparse.ArgumentTypeError(("{!r} is incorrect, "
                                              "should be int > 0").format(s,))
        else:
            return res

    parser = argparse.ArgumentParser(
        description=(
            "Tool to explore and gather statistics about running validator"
        ),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument(
        "-v", "--verbose", action="store_true",
        help="Verbose mode (command line)"
    )
    parser.add_argument(
        "--json", action="store_true",
        help="Format output as JSON (ignores -v)"
    )

    statfile_group = parser.add_argument_group(
        "statfile", "settings for exploring validator stats from stat file"
    )

    statfile_group.add_argument(
        "--statfile", metavar="PATH",
        default=os.path.join(config.baseDir, "stats.json"),
        help=("Path to stats file")
    )
    statfile_group.add_argument(
        "--watch", action="store_true", help="Watch for stats file updates"
    )

    socket_group = parser.add_argument_group(
        "socket", "settings for exploring validator stats from socket"
    )

    socket_group.add_argument(
        "--listen", action="store_true",
        help="Listen socket for stats (ignores --statfile)"
    )

    socket_group.add_argument(
        "-i", "--ip", metavar="IP", default=config.STATS_SERVER_IP,
        help="Server IP"
    )
    socket_group.add_argument(
        "-p", "--port", metavar="PORT", default=config.STATS_SERVER_PORT,
        type=check_unsigned, help="Server port"
    )

    other_group = parser.add_argument_group(
        "other", "other settings"
    )

    other_group.add_argument("--stdlog", action="store_true",
                             help="Enable logging to stdout")

    args = parser.parse_args()

    config.enableStdOutLogging = args.stdlog
    logFileName = os.path.join(config.baseDir,
                               os.path.basename(sys.argv[0] + ".log"))

    logger = getlogger()
    Logger().enableFileLogging(logFileName)

    logger.debug("Cmd line arguments: {}".format(args))

    if args.listen:
        logger.info("Starting server on {}:{} ...".format(args.ip, args.port))
        print("Starting server on {}:{} ...".format(args.ip, args.port))

        loop = asyncio.get_event_loop()
        coro = asyncio.start_server(accept_client,
                                    args.ip, args.port, loop=loop)
        server = loop.run_until_complete(coro)

        logger.info("Serving on {}:{} ...".format(args.ip, args.port))
        print('Serving on {} ...'.format(server.sockets[0].getsockname()))

        # Serve requests until Ctrl+C is pressed
        try:
            loop.run_forever()
        except KeyboardInterrupt:
            pass

        logger.info("Stopping server ...")
        print("Stopping server ...")

        # Close the server
        server.close()
        for task in clients.keys():
            task.cancel()
        loop.run_until_complete(server.wait_closed())
        loop.close()
    else:
        logger.info("Reading file {} ...".format(args.statfile))

        with open(args.statfile) as f:
            stats = json.loads(f.read(), object_pairs_hook=OrderedDict)

        logger.debug("Data {}".format(stats))

        if args.json:
            output_json(stats)
        else:
            output_plain(stats, args.verbose)

    logger.info("Done")


if __name__ == "__main__":
    sys.exit(main())
